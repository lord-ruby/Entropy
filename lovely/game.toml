[manifest]
version = "1.0.0"
dump_lua = true
priority = -1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "table.sort(G.playing_cards, function (a, b) return a.playing_card > b.playing_card end )"
position = "at"
payload = '''
table.sort(G.playing_cards, function (a, b) return (type(a.playing_card) == "number" and a.playing_card or 0) > (type(b.playing_card) == "number" and b.playing_card or 0) end )
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = 'G.GAME.hands[text].played = G.GAME.hands[text].played + 1'
position = "before"
payload = 'if not G.GAME.hands[text] then G.GAME.hands[text] = G.GAME.hands["High Card"] end'
match_indent = true


[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "self.GAME.starting_deck_size = #G.playing_cards"
position = "before"
payload = '''
if G.GAME.modifiers.ccd2 then
    for k, v in pairs(G.playing_cards) do
        local key = ""
        local ptype = pseudorandom_element({
            "Booster",
            "Voucher",
            "Tarot",
            "Joker",
            "Consumeable",
        }, pseudoseed("segfault"))
        if ptype == "Consumeable" then
            key = Cryptid.random_consumable("entr_segfault", nil, "c_entr_segfault").key
        else
            key = pseudorandom_element(G.P_CENTERS, pseudoseed("segfault"))
            local tries = 0
            while key.set ~= ptype or key.no_doe do
                key = pseudorandom_element(G.P_CENTERS, pseudoseed("segfault"))
                tries = tries + 1
            end
            key = key.key
        end
        v:set_ability(G.P_CENTERS[key])
    end
end
'''
match_indent = true


[[patches]]
[patches.pattern]
target = "main.lua"
pattern = '''function love.load() '''
position = "before"
payload = '''
Entropy = {}
Entropy.FlipsideInversions = {}

Entropy.RubySaves = {}

Entropy.ChaosBlacklist = {}
Entropy.ChaosConversions = {}
--for oekrep
Entropy.BoosterSets = {}
--for push -f
Entropy.RarityPoints = {
    [1] = 1, --common
    [2] = 4, --uncommon
    [3] = 12, --rare
    ["cry_epic"] = 60,
    [4] = 300, --legendary
    ["cry_exotic"] = 1000,
    ["entr_hyper_exotic"] = 5000,
}
Entropy.RarityDiminishers = {
    [1] = 1,
    [2] = 1.5,
    [3] = 2.5,
    [4] = 5,
    ["cry_epic"] = 4,
    ["cry_exotic"] = 10,
    ["entr_hyper_exotic"] = 15
}
Entropy.EditionFactors = {
    ["e_foil"] = 1.25,
    ["e_holo"] = 1.45,
    ["e_polychrome"] = 2,
    ["e_negative"] = 2.1,
    ["e_cry_glitched"] = 1.4,
    ["e_cry_mosaic"] = 2.2,
    ["e_cry_oversaturated"] = 1.5,
    ["e_cry_fragile"] = 1.8,
    ["e_cry_gold"] = 1.7,
    ["e_cry_blurred"] = 1.5,
    ["e_cry_noisy"] = 1.7,
    ["e_cry_astral"] = 2.2,
    ["e_cry_m"] = 1.45
}
--for define
Entropy.DefineBlacklist = {}
Entropy.ExoticPlusPlus = {
    ["entr_reverse_legendary"] = true, --this is not above exotic but it needs to be blacklisted anyway
    ["cry_exotic"] = true,
    ["entr_hyper_exotic"] = true
}

--for disavow
Entropy.EnhancementFuncs = {}

--for twisted packs
Entropy.RareInversions = {
    ["c_entr_define"] = "c_entr_define",
    ["c_entr_beyond"] = "c_entr_beyond",
    ["c_entr_fervour"] = "c_entr_fervour"
}

--rarity related stuff
Entropy.RarityChecks = {
    [0]="cry_candy",
    1,
    2,
    3,
    "cry_epic",
    4,
    "cry_exotic",
    "entr_hyper_exotic"
}
Entropy.RarityUppers = {
    ["cry_candy"]=1,
    [1]=2,
    [2]=3,
    [3]="cry_epic",
    ["cry_epic"]=4,
    [4]="cry_exotic",
    ["cry_exotic"]="entr_hyper_exotic"
}

--for destiny
Entropy.FixedRecipes = {
    c_basec_basec_basec_basec_base = "j_joker",
    m_steelm_steelm_steelm_steelm_steel = "j_cry_clockwork"
}
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = 'self.children.card:set_ability(G.P_CENTERS.j_jolly)'
position = "after"
payload = "self.children.card:set_ability(G.P_CENTERS.j_entr_surreal_joker)"
match_indent = true